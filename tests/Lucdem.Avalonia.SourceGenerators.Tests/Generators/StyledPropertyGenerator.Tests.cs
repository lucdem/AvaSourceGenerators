using FluentAssertions;
using Lucdem.Avalonia.SourceGenerators.Attributes;
using Lucdem.Avalonia.SourceGenerators.Generators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;
using System.Reflection;

namespace Lucdem.Avalonia.SourceGenerators.Tests.Generators;


public class StyledPropertyGeneratorTests
{
    static readonly string _assemblyVersion = Assembly.GetExecutingAssembly().GetName().Version?.ToString()
        ?? throw new NullReferenceException(); // this shouldn't ever occur

    [Fact]
    public void StyledPropertyWithNonNullableTypeAsync()
    {
        const string input =
        """
        using Lucdem.Avalonia.SourceGenerators.Attributes;
        
        namespace MyNamespace;
        
        partial class MyClass
        {
            [AvaStyledProperty]
            private int myInt;
        }
        """;

        string expectedOutput =
        $$"""
        // <auto-generated/>
        #pragma warning disable
        #nullable enable
        namespace MyNamespace
        {
            /// <inheritdoc/>
            partial class MyClass
            {
                public static readonly global::Avalonia.StyledProperty<int> MyIntProperty = global::Avalonia.AvaloniaProperty.Register<MyClass, int>("MyInt");
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.StyledPropertyGenerator", "{{_assemblyVersion}}")]
                public int MyInt { get => GetValue(MyIntProperty); set => SetValue(MyIntProperty, value); }
            }
        }
        """;

        VerifyGenerateSources(input, new[] { new StyledPropertyGenerator() }, LanguageVersion.CSharp10, ("MyNamespace.MyClass.g.cs", expectedOutput));
    }

    [Fact]
    public void StyledPropertyWithNullableType()
    {
        const string input =
        """
        using Lucdem.Avalonia.SourceGenerators.Attributes;
        
        namespace MyNamespace;
        
        partial class MyClass
        {
            [AvaStyledProperty]
            private int? myInt;
        }
        """;

        string expectedOutput =
        $$"""
        // <auto-generated/>
        #pragma warning disable
        #nullable enable
        namespace MyNamespace
        {
            /// <inheritdoc/>
            partial class MyClass
            {
                public static readonly global::Avalonia.StyledProperty<int?> MyIntProperty = global::Avalonia.AvaloniaProperty.Register<MyClass, int?>("MyInt");
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.StyledPropertyGenerator", "{{_assemblyVersion}}")]
                public int? MyInt { get => GetValue(MyIntProperty); set => SetValue(MyIntProperty, value); }
            }
        }
        """;

        VerifyGenerateSources(input, new[] { new StyledPropertyGenerator() }, LanguageVersion.CSharp10, ("MyNamespace.MyClass.g.cs", expectedOutput));
    }

    [Fact]
    public void StyledPropertyWithGenericType()
    {
        const string input =
"""
        using Lucdem.Avalonia.SourceGenerators.Attributes;
        using System.Collections.Generic;

        namespace MyNamespace;
        
        partial class MyClass
        {
            [AvaStyledProperty]
            private List<int?> myInts;
        }
        """;

        string expectedOutput =
        $$"""
        // <auto-generated/>
        #pragma warning disable
        #nullable enable
        namespace MyNamespace
        {
            /// <inheritdoc/>
            partial class MyClass
            {
                public static readonly global::Avalonia.StyledProperty<global::System.Collections.Generic.List<int?>> MyIntsProperty = global::Avalonia.AvaloniaProperty.Register<MyClass, global::System.Collections.Generic.List<int?>>("MyInts");
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.StyledPropertyGenerator", "{{_assemblyVersion}}")]
                public global::System.Collections.Generic.List<int?> MyInts { get => GetValue(MyIntsProperty); set => SetValue(MyIntsProperty, value); }
            }
        }
        """;

        VerifyGenerateSources(input, new[] { new StyledPropertyGenerator() }, LanguageVersion.CSharp10, ("MyNamespace.MyClass.g.cs", expectedOutput));
    }

    [Fact]
    public void StyledPropertyWithTupleType()
    {
        const string input =
        """
        using Lucdem.Avalonia.SourceGenerators.Attributes;

        namespace MyNamespace;
        
        partial class MyClass
        {
            [AvaStyledProperty]
            private (int i, string s) myTup;
        }
        """;

        string expectedOutput =
        $$"""
        // <auto-generated/>
        #pragma warning disable
        #nullable enable
        namespace MyNamespace
        {
            /// <inheritdoc/>
            partial class MyClass
            {
                public static readonly global::Avalonia.StyledProperty<(int i, string s)> MyTupProperty = global::Avalonia.AvaloniaProperty.Register<MyClass, (int i, string s)>("MyTup");
                [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.StyledPropertyGenerator", "{{_assemblyVersion}}")]
                public (int i, string s) MyTup { get => GetValue(MyTupProperty); set => SetValue(MyTupProperty, value); }
            }
        }
        """;

        VerifyGenerateSources(input, new[] { new StyledPropertyGenerator() }, LanguageVersion.CSharp10, ("MyNamespace.MyClass.g.cs", expectedOutput));
    }

    private static void VerifyGenerateSources(string source, IIncrementalGenerator[] generators, LanguageVersion languageVersion, params (string Filename, string? Text)[] results)
    {
        // Ensure CommunityToolkit.Mvvm and System.ComponentModel.DataAnnotations are loaded
        Type observableObjectType = typeof(AvaStyledPropertyAttribute);

        // Get all assembly references for the loaded assemblies (easy way to pull in all necessary dependencies)
        IEnumerable<MetadataReference> references =
            from assembly in AppDomain.CurrentDomain.GetAssemblies()
            where !assembly.IsDynamic
            let reference = MetadataReference.CreateFromFile(assembly.Location)
            select reference;

        SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source, CSharpParseOptions.Default.WithLanguageVersion(languageVersion));

        // Create a syntax tree with the input source
        CSharpCompilation compilation = CSharpCompilation.Create(
            "original",
            new SyntaxTree[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generators).WithUpdatedParseOptions((CSharpParseOptions)syntaxTree.Options);

        // Run all source generators on the input source code
        _ = driver.RunGeneratorsAndUpdateCompilation(compilation, out Compilation outputCompilation, out ImmutableArray<Diagnostic> diagnostics);

        diagnostics.Should().BeEmpty();

        foreach ((string filename, string? text) in results)
        {
            if (text is not null)
            {
                string filePath = filename;


#if !ROSLYN_4_3_1_OR_GREATER
                // Adjust the filenames for the legacy Roslyn 4.0
                filePath = filePath.Replace('`', '_');
#endif

                SyntaxTree generatedTree = outputCompilation.SyntaxTrees.Single(tree => Path.GetFileName(tree.FilePath) == filePath);

                var generatedText = generatedTree.ToString();
                generatedText.Should().Be(text);
            }
            else
            {
                outputCompilation.SyntaxTrees
                    .Any(tree => Path.GetFileName(tree.FilePath) == filename)
                    .Should()
                    .BeFalse();
            }
        }

        GC.KeepAlive(observableObjectType);
    }
}