using FluentAssertions;
using Lucdem.Avalonia.SourceGenerators.Attributes;
using Lucdem.Avalonia.SourceGenerators.Generators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;
using System.Reflection;

namespace Lucdem.Avalonia.SourceGenerators.Tests.Generators;

public class DirectPropertyGeneratorTests
{
    static readonly string _assemblyVersion = Assembly.GetExecutingAssembly().GetName().Version?.ToString()
                                              ?? throw new NullReferenceException(); // this shouldn't ever occur

    [Fact]
    public void GeneratePropertyFromLeadingUnderscoreField()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private int _myInt;
            }
            """;

        string expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, int> MyIntProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, int>(
                              "MyInt",
                              o => o.MyInt,
                              (o, v) => o.MyInt = v);
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public int MyInt { get => _myInt; set => SetAndRaise(MyIntProperty, ref _myInt, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }
    
    [Fact]
    public void GeneratePropertyFromNonNullableTypeField()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private int myInt;
            }
            """;

        string expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, int> MyIntProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, int>(
                              "MyInt",
                              o => o.MyInt,
                              (o, v) => o.MyInt = v);
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public int MyInt { get => myInt; set => SetAndRaise(MyIntProperty, ref myInt, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }
    
    [Fact]
    public void GeneratePropertyFromNullableTypeField()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private int? myInt;
            }
            """;

        string expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, int?> MyIntProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, int?>(
                              "MyInt",
                              o => o.MyInt,
                              (o, v) => o.MyInt = v);
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public int? MyInt { get => myInt; set => SetAndRaise(MyIntProperty, ref myInt, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }
    
    [Fact]
    public void GeneratePropertyFromGenericTypeField()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private List<int> myList;
            }
            """;

        string expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, List<int>> MyListProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, List<int>>(
                              "MyList",
                              o => o.MyList,
                              (o, v) => o.MyList = v);
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public List<int> MyList { get => myList; set => SetAndRaise(MyListProperty, ref myList, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }
    
    [Fact]
    public void GeneratePropertyFromTupleTypeField()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private (int, string) myTuple;
            }
            """;

        string expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, (int, string)> MyTupleProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, (int, string)>(
                              "MyTuple",
                              o => o.MyTuple,
                              (o, v) => o.MyTuple = v);
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public (int, string) MyTuple { get => myTuple; set => SetAndRaise(MyTupleProperty, ref myTuple, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }
    
    [Fact]
    public void GeneratePropertiesFromMultipleFields()
    {
        const string input =
            """
            using Lucdem.Avalonia.SourceGenerators.Attributes;

            namespace MyNamespace;

            partial class MyClass
            {
                [AvaDirectProperty]
                private int myInt;
                
                [AvaDirectProperty]
                private float myFloat;
            }
            """;

        var expectedOutput =
            $$"""
              // <auto-generated/>
              #pragma warning disable
              #nullable enable
              namespace MyNamespace
              {
                  /// <inheritdoc/>
                  partial class MyClass
                  {
                      public static readonly global::Avalonia.DirectProperty<MyClass, int> MyIntProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, int>(
                              "MyInt",
                              o => o.MyInt,
                              (o, v) => o.MyInt = v);
                              
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public int MyInt { get => myInt; set => SetAndRaise(MyIntProperty, ref myInt, value); }
                      
                      public static readonly global::Avalonia.DirectProperty<MyClass, float> MyFloatProperty
                          = global::Avalonia.AvaloniaProperty.RegisterDirect<MyClass, float>(
                              "MyFloat",
                              o => o.MyFloat,
                              (o, v) => o.MyFloat = v);
                              
                      [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
                      [global::System.CodeDom.Compiler.GeneratedCode("Lucdem.Avalonia.SourceGenerators.Generators.DirectPropertyGenerator", "{{_assemblyVersion}}")]
                      public float MyFloat { get => myFloat; set => SetAndRaise(MyFloatProperty, ref myFloat, value); }
                  }
              }
              """;

        VerifyGenerateSources(
            input,
            [new DirectPropertyGenerator()],
            LanguageVersion.CSharp10,
            ("MyNamespace.MyClass.g.cs", expectedOutput));
    }

    private static void VerifyGenerateSources(
        string source,
        IIncrementalGenerator[] generators,
        LanguageVersion languageVersion,
        params (string Filename, string? Text)[] expectedResults)
    {
        // Ensure it is loaded
        Type observableObjectType = typeof(AvaDirectPropertyAttribute);

        // Get all assembly references for the loaded assemblies (easy way to pull in all necessary dependencies)
        IEnumerable<MetadataReference> references =
            from assembly in AppDomain.CurrentDomain.GetAssemblies()
            where !assembly.IsDynamic
            let reference = MetadataReference.CreateFromFile(assembly.Location)
            select reference;

        SyntaxTree syntaxTree =
            CSharpSyntaxTree.ParseText(source, CSharpParseOptions.Default.WithLanguageVersion(languageVersion));

        // Create a syntax tree with the input source
        CSharpCompilation compilation = CSharpCompilation.Create(
            "original",
            new SyntaxTree[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        GeneratorDriver driver = CSharpGeneratorDriver.Create(generators)
            .WithUpdatedParseOptions((CSharpParseOptions)syntaxTree.Options);

        // Run all source generators on the input source code
        _ = driver.RunGeneratorsAndUpdateCompilation(compilation, out Compilation outputCompilation,
            out ImmutableArray<Diagnostic> diagnostics);

        diagnostics.Should().BeEmpty();

        foreach ((string filename, string? expectedText) in expectedResults)
        {
            if (expectedText is null)
            {
                outputCompilation.SyntaxTrees
                    .Any(tree => Path.GetFileName(tree.FilePath) == filename)
                    .Should()
                    .BeFalse();
                continue;
            }

#if !ROSLYN_4_3_1_OR_GREATER
            // Adjust the filenames for the legacy Roslyn 4.0
            var filePath = filename.Replace('`', '_');
#else
            var filePath = filename;
#endif

            SyntaxTree generatedTree =
                outputCompilation.SyntaxTrees.Single(tree => Path.GetFileName(tree.FilePath) == filePath);

            var generatedText = generatedTree.ToString();
            var normalizedExpectedOutput = CSharpSyntaxTree.ParseText(expectedText).GetRoot().NormalizeWhitespace().ToFullString();
            generatedText.Should().Be(normalizedExpectedOutput);
        }

        GC.KeepAlive(observableObjectType);
    }
}